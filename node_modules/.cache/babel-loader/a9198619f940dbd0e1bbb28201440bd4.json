{"ast":null,"code":"function Astar(startNode, endNode) {\n  let openSet = [];\n  let closedSet = [];\n  let path = [];\n  openSet.push(startNode);\n\n  while (openSet.length > 0) {\n    let leastIndex = 0;\n\n    for (let i = 0; i < openSet.length; i++) {\n      if (openSet[i].f < openSet[leastIndex].f) {\n        leastIndex = i;\n      }\n    }\n\n    let current = openSet[leastIndex];\n\n    if (current === endNode) {\n      let temp = current;\n      path.push(temp);\n\n      while (temp.previous) {\n        path.push(temp.previous);\n        temp = temp.previous;\n      }\n\n      return path;\n    }\n\n    openSet = openSet.filter(elt => elt !== current);\n    closedSet.push(current);\n    let neighbors = current.neighbors;\n\n    for (let i = 0; i < neighbors.length; i++) {\n      let neighbor = neighbors[i];\n\n      if (!closedSet.includes(neighbor)) {\n        let tempG = current.g + 1;\n        let newPath = false;\n\n        if (openSet.includes(neighbor)) {\n          if (tempG < neighbor.g) {\n            neighbor.g = tempG;\n            newPath = true;\n          }\n        } else {\n          neighbor.g = tempG;\n          newPath = true;\n          openSet.push(neighbor);\n        }\n\n        if (newPath) {\n          neighbor.h = heruistic(neighbor, endNode);\n          neighbor.f = neighbor.h + neighbor.g;\n          neighbor.previous = current;\n        }\n      }\n    }\n  }\n\n  return {\n    path,\n    error: \"No Path found!\"\n  };\n}\n\n_c = Astar;\n\nfunction heruistic(a, b) {\n  let d = Math.abs(a.x - a.y) + Math.abs(b.x - b.y);\n  return d;\n}\n\nexport default Astar;\n\nvar _c;\n\n$RefreshReg$(_c, \"Astar\");","map":{"version":3,"sources":["C:/Users/Antoni/Desktop/pathfinder/src/astarAlgorithm/astar.js"],"names":["Astar","startNode","endNode","openSet","closedSet","path","push","length","leastIndex","i","f","current","temp","previous","filter","elt","neighbors","neighbor","includes","tempG","g","newPath","h","heruistic","error","a","b","d","Math","abs","x","y"],"mappings":"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","sourcesContent":["function Astar(startNode, endNode){\r\n    let openSet = []\r\n    let closedSet = []\r\n    let path = [];\r\n\r\n    openSet.push(startNode);\r\n    while(openSet.length > 0){\r\n            let leastIndex = 0;\r\n            for(let i = 0; i < openSet.length; i++){\r\n                if(openSet[i].f < openSet[leastIndex].f){\r\n                    leastIndex = i;\r\n                }\r\n            }\r\n        \r\n\r\n        let current = openSet[leastIndex];\r\n\r\n        if(current === endNode){\r\n            let temp = current;\r\n            path.push(temp);\r\n            while(temp.previous){\r\n                path.push(temp.previous);\r\n                temp = temp.previous;\r\n            }\r\n            return path; \r\n        }\r\n\r\n        openSet = openSet.filter(elt => elt !== current);\r\n        closedSet.push(current);\r\n\r\n        let neighbors = current.neighbors;\r\n        for(let i = 0; i<neighbors.length; i++){\r\n            let neighbor = neighbors[i];\r\n            if(!closedSet.includes(neighbor)){\r\n                let tempG = current.g + 1;\r\n                let newPath = false;\r\n\r\n                if(openSet.includes(neighbor)){\r\n                    if(tempG < neighbor.g){\r\n                        neighbor.g = tempG;\r\n                        newPath = true;\r\n                    }\r\n\r\n                }else{\r\n                    neighbor.g = tempG;\r\n                    newPath = true;\r\n                    openSet.push(neighbor);\r\n                }\r\n                if(newPath){\r\n                    neighbor.h = heruistic(neighbor, endNode);\r\n                    neighbor.f = neighbor.h + neighbor.g;\r\n                    neighbor.previous = current;\r\n\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return {path, error: \"No Path found!\"}\r\n\r\n}\r\n\r\nfunction heruistic(a, b){\r\n    let d = Math.abs(a.x - a.y) + Math.abs(b.x - b.y);\r\n    return d;\r\n}\r\n\r\nexport default Astar;"]},"metadata":{},"sourceType":"module"}