{"ast":null,"code":"function Astar(startNode, endNode) {\n  let openSet = [];\n  let closedSet = [];\n  let path = [];\n  openSet.push(startNode);\n\n  while (openSet.length > 0) {\n    let leastIndex = 0;\n\n    for (let i = 0; i < openSet.length; i++) {\n      if (openSet[i].f < openSet[leastIndex].f) {\n        leastIndex = i;\n      }\n    }\n  }\n\n  let current = openSet[leastIndex];\n\n  if (current === endNode) {\n    console.log(\"Done! Path Found\");\n  }\n\n  openSet = openSet.filter(elt => elt !== current);\n  closedSet.push(current);\n  let neighbors = current.neighbors;\n\n  for (let i = 0; i < neighbors.length; i++) {\n    let neighbor = neighbors[i];\n\n    if (!closedSet.includes(neighbor)) {\n      let tempG = current.g + 1;\n      let newPath = false;\n\n      if (openSet.includes(neighbor)) {\n        if (tempG < neighbor.g) {\n          neighbor.g = tempG;\n          newPath = true;\n        }\n      } else {\n        neighbor.g = tempG;\n        newPath = true;\n        openSet.push(neighbor);\n      }\n\n      if (newPath) {\n        neighbor.h = heruistic(neighbor, endNode);\n        neighbor.f = neighbor.h + neighbor.g;\n        neighbor.previous = current;\n      }\n    }\n  }\n}\n\n_c = Astar;\n\nfunction heruistic(a, b) {\n  let d = Math.abs(a.x - a.y) + Math.abs(b.x - b.y);\n  return d;\n}\n\nexport default Astar;\n\nvar _c;\n\n$RefreshReg$(_c, \"Astar\");","map":{"version":3,"sources":["C:/Users/Antoni/Desktop/pathfinder/src/astarAlgorithm/astar.js"],"names":["Astar","startNode","endNode","openSet","closedSet","path","push","length","leastIndex","i","f","current","console","log","filter","elt","neighbors","neighbor","includes","tempG","g","newPath","h","heruistic","previous","a","b","d","Math","abs","x","y"],"mappings":"AAAA,SAASA,KAAT,CAAeC,SAAf,EAA0BC,OAA1B,EAAkC;AAC9B,MAAIC,OAAO,GAAG,EAAd;AACA,MAAIC,SAAS,GAAG,EAAhB;AACA,MAAIC,IAAI,GAAG,EAAX;AAEAF,EAAAA,OAAO,CAACG,IAAR,CAAaL,SAAb;;AACA,SAAME,OAAO,CAACI,MAAR,GAAiB,CAAvB,EAAyB;AACrB,QAAIC,UAAU,GAAG,CAAjB;;AACA,SAAI,IAAIC,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGN,OAAO,CAACI,MAA3B,EAAmCE,CAAC,EAApC,EAAuC;AACnC,UAAGN,OAAO,CAACM,CAAD,CAAP,CAAWC,CAAX,GAAeP,OAAO,CAACK,UAAD,CAAP,CAAoBE,CAAtC,EAAwC;AACpCF,QAAAA,UAAU,GAAGC,CAAb;AACH;AACJ;AACJ;;AAED,MAAIE,OAAO,GAAGR,OAAO,CAACK,UAAD,CAArB;;AAEA,MAAGG,OAAO,KAAIT,OAAd,EAAsB;AAClBU,IAAAA,OAAO,CAACC,GAAR,CAAY,kBAAZ;AACH;;AAEDV,EAAAA,OAAO,GAAGA,OAAO,CAACW,MAAR,CAAeC,GAAG,IAAIA,GAAG,KAAKJ,OAA9B,CAAV;AACAP,EAAAA,SAAS,CAACE,IAAV,CAAeK,OAAf;AAEA,MAAIK,SAAS,GAAGL,OAAO,CAACK,SAAxB;;AACA,OAAI,IAAIP,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAACO,SAAS,CAACT,MAA3B,EAAmCE,CAAC,EAApC,EAAuC;AACnC,QAAIQ,QAAQ,GAAGD,SAAS,CAACP,CAAD,CAAxB;;AACA,QAAG,CAACL,SAAS,CAACc,QAAV,CAAmBD,QAAnB,CAAJ,EAAiC;AAC7B,UAAIE,KAAK,GAAGR,OAAO,CAACS,CAAR,GAAY,CAAxB;AACA,UAAIC,OAAO,GAAG,KAAd;;AAEA,UAAGlB,OAAO,CAACe,QAAR,CAAiBD,QAAjB,CAAH,EAA8B;AAC1B,YAAGE,KAAK,GAAGF,QAAQ,CAACG,CAApB,EAAsB;AAClBH,UAAAA,QAAQ,CAACG,CAAT,GAAaD,KAAb;AACAE,UAAAA,OAAO,GAAG,IAAV;AACH;AAEJ,OAND,MAMK;AACDJ,QAAAA,QAAQ,CAACG,CAAT,GAAaD,KAAb;AACAE,QAAAA,OAAO,GAAG,IAAV;AACAlB,QAAAA,OAAO,CAACG,IAAR,CAAaW,QAAb;AACH;;AACD,UAAGI,OAAH,EAAW;AACPJ,QAAAA,QAAQ,CAACK,CAAT,GAAaC,SAAS,CAACN,QAAD,EAAWf,OAAX,CAAtB;AACAe,QAAAA,QAAQ,CAACP,CAAT,GAAaO,QAAQ,CAACK,CAAT,GAAaL,QAAQ,CAACG,CAAnC;AACAH,QAAAA,QAAQ,CAACO,QAAT,GAAoBb,OAApB;AAEH;AACJ;AACJ;AAEJ;;KAnDQX,K;;AAqDT,SAASuB,SAAT,CAAmBE,CAAnB,EAAsBC,CAAtB,EAAwB;AACpB,MAAIC,CAAC,GAAGC,IAAI,CAACC,GAAL,CAASJ,CAAC,CAACK,CAAF,GAAML,CAAC,CAACM,CAAjB,IAAsBH,IAAI,CAACC,GAAL,CAASH,CAAC,CAACI,CAAF,GAAMJ,CAAC,CAACK,CAAjB,CAA9B;AACA,SAAOJ,CAAP;AACH;;AAED,eAAe3B,KAAf","sourcesContent":["function Astar(startNode, endNode){\r\n    let openSet = []\r\n    let closedSet = []\r\n    let path = [];\r\n\r\n    openSet.push(startNode);\r\n    while(openSet.length > 0){\r\n        let leastIndex = 0;\r\n        for(let i = 0; i < openSet.length; i++){\r\n            if(openSet[i].f < openSet[leastIndex].f){\r\n                leastIndex = i;\r\n            }\r\n        }\r\n    }\r\n\r\n    let current = openSet[leastIndex];\r\n\r\n    if(current ===endNode){\r\n        console.log(\"Done! Path Found\");\r\n    }\r\n\r\n    openSet = openSet.filter(elt => elt !== current);\r\n    closedSet.push(current);\r\n\r\n    let neighbors = current.neighbors;\r\n    for(let i = 0; i<neighbors.length; i++){\r\n        let neighbor = neighbors[i];\r\n        if(!closedSet.includes(neighbor)){\r\n            let tempG = current.g + 1;\r\n            let newPath = false;\r\n\r\n            if(openSet.includes(neighbor)){\r\n                if(tempG < neighbor.g){\r\n                    neighbor.g = tempG;\r\n                    newPath = true;\r\n                }\r\n\r\n            }else{\r\n                neighbor.g = tempG;\r\n                newPath = true;\r\n                openSet.push(neighbor);\r\n            }\r\n            if(newPath){\r\n                neighbor.h = heruistic(neighbor, endNode);\r\n                neighbor.f = neighbor.h + neighbor.g;\r\n                neighbor.previous = current;\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n\r\nfunction heruistic(a, b){\r\n    let d = Math.abs(a.x - a.y) + Math.abs(b.x - b.y);\r\n    return d;\r\n}\r\n\r\nexport default Astar;"]},"metadata":{},"sourceType":"module"}